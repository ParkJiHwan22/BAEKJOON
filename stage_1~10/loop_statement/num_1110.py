# 문제
# 0보다 크거나 같고, 99보다 작거나 같은 정수가 주어질 때 다음과 같은 연산을 할 수 있다.
# 먼저 주어진 수가 10보다 작다면 앞에 0을 붙여 두 자리 수로 만들고, 각 자리의 숫자를 더한다.
# 그 다음, 주어진 수의 가장 오른쪽 자리 수와 앞에서 구한 합의 가장 오른쪽 자리 수를 이어 
# 붙이면 새로운 수를 만들 수 있다. 다음 예를 보자.

# 26부터 시작한다. 2+6 = 8이다. 새로운 수는 68이다. 6+8 = 14이다. 
# 새로운 수는 84이다. 8+4 = 12이다. 새로운 수는 42이다. 4+2 = 6이다. 
# 새로운 수는 26이다.

# 위의 예는 4번만에 원래 수로 돌아올 수 있다. 따라서 26의 사이클의 길이는 4이다.

# N이 주어졌을 때, N의 사이클의 길이를 구하는 프로그램을 작성하시오.

# 입력
# 첫째 줄에 N이 주어진다. N은 0보다 크거나 같고, 99보다 작거나 같은 정수이다.

# 출력
# 첫째 줄에 N의 사이클 길이를 출력한다.

N = int(input())
count = 0

a, b = N // 10, N % 10
c = a + b
count += 1
c = b * 10 + c % 10

while (1):
    if N == c:
        print(count)
        break

    else:
        d = 0
        count += 1
        c = str(c)
        for element in c:
            d += int(element)
        c = int(c)
        c = c % 10 * 10 + d % 10

# 3시간 가까이 풀었다. 결과 값이 실행됐을 때 저절로 탄성을 지르게 한 문제
# 몫과 나머지로 접근 하는데까지 시간이 조금 걸렸다. (2시간 반 남짓)
# 머리를 비우고 이 닦으면서 생각이 난 걸 보니 확실히 refresh가 중요한 것 같다.
# 도식화해서 그림으로 그리다보니 구조가 조금 보였다.

input_num = int(input())

num = input_num  # num 변수에 input_num을 지정
cnt = 0
while True:
    sum_num = (num // 10) + (num % 10)  # 각 자릿수를 더한수
    new_num = ((num % 10) * 10) + (sum_num % 10)  # 새로 만들어지는 수
    cnt += 1  # 사이클 카운트
    if new_num == input_num :
        break
    num = new_num  # num 변수에 last_num을 지정 
print(cnt)

# 나는 N 을 유지하기 위해 미리 한 사이클을 돌린 후 while문을 썼는데 여기서는 새로운 함수 num에 넣고 썼다
# 생각을 조금더 간결하게 정리하는 연습을 하자!


# 예제 입력 1 
# 26
# 예제 출력 1 
# 4

# 예제 입력 2 
# 55
# 예제 출력 2 
# 3

# 예제 입력 3 
# 1
# 예제 출력 3 
# 60

# 예제 입력 4 
# 0
# 예제 출력 4 
# 1

# 예제 입력 5 
# 71
# 예제 출력 5 
# 12